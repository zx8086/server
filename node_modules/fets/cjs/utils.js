"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addHandlersToMethod = void 0;
// This is used on runtime for optimization
function preparePatternHandlerObjByMethod({ handlersByPatternByMethod, patternHandlerObjByMethod, }) {
    for (const [method, patternHandlersMap] of handlersByPatternByMethod) {
        const patternHandlerObjList = [];
        for (const [pattern, handlers] of patternHandlersMap) {
            patternHandlerObjList.push({
                pattern,
                handlers,
            });
        }
        patternHandlerObjByMethod.set(method, patternHandlerObjList);
    }
}
function addHandlersToMethod({ operationId, description, tags, method, path, schemas, handlers, internal, onRouteHooks, openAPIDocument, basePath, fetchAPI, handlersByPatternByMethod, internalPatternsByMethod, patternHandlerObjByMethod, }) {
    for (const onRouteHook of onRouteHooks) {
        onRouteHook({
            operationId,
            description,
            tags,
            openAPIDocument,
            method,
            path,
            schemas,
            handlers,
        });
    }
    let methodPatternMaps = handlersByPatternByMethod.get(method);
    if (!methodPatternMaps) {
        methodPatternMaps = new Map();
        handlersByPatternByMethod.set(method, methodPatternMaps);
    }
    let fullPath = '';
    if (basePath === '/') {
        fullPath = path;
    }
    else if (path === '/') {
        fullPath = basePath;
    }
    else {
        fullPath = `${basePath}${path}`;
    }
    const pattern = new fetchAPI.URLPattern({ pathname: fullPath });
    pattern.isPattern = fullPath.includes(':') || fullPath.includes('*');
    methodPatternMaps.set(pattern, handlers);
    // TODO: Better logic to make sure internal routes are always last
    let internalPatterns = internalPatternsByMethod.get(method);
    if (internal) {
        if (!internalPatterns) {
            internalPatterns = new Set();
            internalPatternsByMethod.set(method, internalPatterns);
        }
        internalPatterns.add(pattern);
    }
    if (internalPatterns?.size) {
        handlersByPatternByMethod.set(method, new Map([...methodPatternMaps.entries()].sort(([a], [b]) => {
            if (internalPatterns.has(a)) {
                return 1;
            }
            else if (internalPatterns.has(b)) {
                return -1;
            }
            return 0;
        })));
    }
    preparePatternHandlerObjByMethod({
        handlersByPatternByMethod,
        patternHandlerObjByMethod,
    });
}
exports.addHandlersToMethod = addHandlersToMethod;
