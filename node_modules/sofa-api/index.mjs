import { __awaiter, __asyncValues } from 'tslib';
import { getOperationAST, Kind, isScalarType, isEqualType, GraphQLBoolean, isInputObjectType, isNonNullType, isListType, isObjectType, isEnumType, parse, printType, isIntrospectionType, execute, subscribe, getNamedType } from 'graphql';
import { buildOperationNodeForField, createGraphQLError } from '@graphql-tools/utils';
import { paramCase } from 'param-case';
import { crypto, fetch } from '@whatwg-node/fetch';
import colors from 'ansi-colors';
import { createRouter as createRouter$1, Response } from 'fets';
import { titleCase } from 'title-case';

function getOperationInfo(doc) {
    const op = getOperationAST(doc, null);
    if (!op) {
        return;
    }
    return {
        operation: op,
        name: op.name.value,
        variables: op.variableDefinitions || [],
    };
}

function convertName(name) {
    return paramCase(name);
}
function isNil(val) {
    return val == null;
}

function parseVariable({ value, variable, schema, }) {
    if (isNil(value)) {
        return;
    }
    return resolveVariable({
        value,
        type: variable.type,
        schema,
    });
}
function resolveVariable({ value, type, schema, }) {
    if (type.kind === Kind.NAMED_TYPE) {
        const namedType = schema.getType(type.name.value);
        if (isScalarType(namedType)) {
            // GraphQLBoolean.serialize expects a boolean or a number only
            if (isEqualType(GraphQLBoolean, namedType)) {
                value = (value === 'true' || value === true);
            }
            return namedType.serialize(value);
        }
        if (isInputObjectType(namedType)) {
            return value && typeof value === 'object' ? value : JSON.parse(value);
        }
        return value;
    }
    if (type.kind === Kind.LIST_TYPE) {
        return (Array.isArray(value) ? value : [value]).map((val) => resolveVariable({
            value: val,
            type: type.type,
            schema,
        }));
    }
    if (type.kind === Kind.NON_NULL_TYPE) {
        return resolveVariable({
            value: value,
            type: type.type,
            schema,
        });
    }
}

var _a, _b, _c, _d, _e;
const levels = ['error', 'warn', 'info', 'debug'];
const toLevel = (string) => levels.includes(string) ? string : null;
const currentLevel = ((_b = (_a = globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.SOFA_DEBUG)
    ? 'debug'
    : (_e = toLevel((_d = (_c = globalThis.process) === null || _c === void 0 ? void 0 : _c.env) === null || _d === void 0 ? void 0 : _d.SOFA_LOGGER_LEVEL)) !== null && _e !== void 0 ? _e : 'info';
const log = (level, color, args) => {
    if (levels.indexOf(level) <= levels.indexOf(currentLevel)) {
        console.log(`${color(level)}:`, ...args);
    }
};
const logger = {
    error: (...args) => {
        log('error', colors.red, args);
    },
    warn: (...args) => {
        log('warn', colors.yellow, args);
    },
    info: (...args) => {
        log('info', colors.green, args);
    },
    debug: (...args) => {
        log('debug', colors.blue, args);
    },
};

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}
class SubscriptionManager {
    constructor(sofa) {
        this.sofa = sofa;
        this.operations = new Map();
        this.clients = new Map();
        this.buildOperations();
    }
    start(event, contextValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = crypto.randomUUID();
            const name = event.subscription;
            if (!this.operations.has(name)) {
                throw new Error(`Subscription '${name}' is not available`);
            }
            logger.info(`[Subscription] Start ${id}`, event);
            const result = yield this.execute({
                id,
                name,
                url: event.url,
                variables: event.variables,
                contextValue,
            });
            if (typeof result !== 'undefined') {
                return result;
            }
            return { id };
        });
    }
    stop(id) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`[Subscription] Stop ${id}`);
            if (!this.clients.has(id)) {
                throw new Error(`Subscription with ID '${id}' does not exist`);
            }
            const execution = this.clients.get(id);
            if (execution.iterator.return) {
                execution.iterator.return();
            }
            this.clients.delete(id);
            return { id };
        });
    }
    update(event, contextValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const { variables, id } = event;
            logger.info(`[Subscription] Update ${id}`, event);
            if (!this.clients.has(id)) {
                throw new Error(`Subscription with ID '${id}' does not exist`);
            }
            const { name: subscription, url } = this.clients.get(id);
            this.stop(id);
            return this.start({
                url,
                subscription,
                variables,
            }, contextValue);
        });
    }
    execute({ id, name, url, variables, contextValue, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { document, operationName, variables: variableNodes } = this.operations.get(name);
            const variableValues = variableNodes.reduce((values, variable) => {
                const value = parseVariable({
                    value: variables[variable.variable.name.value],
                    variable,
                    schema: this.sofa.schema,
                });
                if (typeof value === 'undefined') {
                    return values;
                }
                return Object.assign(Object.assign({}, values), { [variable.variable.name.value]: value });
            }, {});
            const execution = yield this.sofa.subscribe({
                schema: this.sofa.schema,
                document,
                operationName,
                variableValues,
                contextValue,
            });
            if (isAsyncIterable(execution)) {
                // successful
                // add execution to clients
                this.clients.set(id, {
                    name,
                    url,
                    iterator: execution,
                });
                // success
                (() => __awaiter(this, void 0, void 0, function* () {
                    var _a, e_1, _b, _c;
                    try {
                        for (var _d = true, execution_1 = __asyncValues(execution), execution_1_1; execution_1_1 = yield execution_1.next(), _a = execution_1_1.done, !_a;) {
                            _c = execution_1_1.value;
                            _d = false;
                            try {
                                const result = _c;
                                yield this.sendData({
                                    id,
                                    result,
                                });
                            }
                            finally {
                                _d = true;
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (!_d && !_a && (_b = execution_1.return)) yield _b.call(execution_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }))().then(() => {
                    // completes
                    this.clients.delete(id);
                }, (e) => {
                    logger.info(`Subscription #${id} closed`);
                    logger.error(e);
                    this.clients.delete(id);
                });
            }
            else {
                return execution;
            }
        });
    }
    sendData({ id, result }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.clients.has(id)) {
                throw new Error(`Subscription with ID '${id}' does not exist`);
            }
            const { url } = this.clients.get(id);
            logger.info(`[Subscription] Trigger ${id}`);
            const response = yield fetch(url, {
                method: 'POST',
                body: JSON.stringify(result),
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            yield response.text();
        });
    }
    buildOperations() {
        const subscription = this.sofa.schema.getSubscriptionType();
        if (!subscription) {
            return;
        }
        const fieldMap = subscription.getFields();
        for (const field in fieldMap) {
            const operationNode = buildOperationNodeForField({
                kind: 'subscription',
                field,
                schema: this.sofa.schema,
                models: this.sofa.models,
                ignore: this.sofa.ignore,
                circularReferenceDepth: this.sofa.depthLimit,
            });
            const document = {
                kind: Kind.DOCUMENT,
                definitions: [operationNode],
            };
            const { variables, name: operationName } = getOperationInfo(document);
            this.operations.set(field, {
                operationName,
                document,
                variables,
            });
        }
    }
}

function mapToPrimitive(type) {
    const formatMap = {
        Int: {
            type: 'integer',
            format: 'int32',
        },
        Float: {
            type: 'number',
            format: 'float',
        },
        String: {
            type: 'string',
        },
        Boolean: {
            type: 'boolean',
        },
        ID: {
            type: 'string',
        },
    };
    if (formatMap[type]) {
        return formatMap[type];
    }
}
function mapToRef(type) {
    return `#/components/schemas/${type}`;
}
function normalizePathParamForOpenAPI(path) {
    const pathParts = path.split('/');
    const normalizedPathParts = pathParts.map((part) => {
        if (part.startsWith(':')) {
            return `{${part.slice(1)}}`;
        }
        return part;
    });
    return normalizedPathParts.join('/');
}

function buildSchemaObjectFromType(type, opts) {
    const required = [];
    const properties = {};
    const fields = type.getFields();
    for (const fieldName in fields) {
        const field = fields[fieldName];
        if (isNonNullType(field.type)) {
            required.push(field.name);
        }
        properties[fieldName] = resolveField(field, opts);
        if (field.description) {
            properties[fieldName].description = field.description;
        }
    }
    return Object.assign(Object.assign(Object.assign({ type: 'object' }, (required.length ? { required } : {})), { properties }), (type.description ? { description: type.description } : {}));
}
function resolveField(field, opts) {
    return resolveFieldType(field.type, opts);
}
// array -> [type]
// type -> $ref
// scalar -> swagger primitive
function resolveFieldType(type, opts) {
    var _a;
    if (isNonNullType(type)) {
        return resolveFieldType(type.ofType, opts);
    }
    if (isListType(type)) {
        return {
            type: 'array',
            items: resolveFieldType(type.ofType, opts),
        };
    }
    if (isObjectType(type)) {
        return {
            $ref: mapToRef(type.name),
        };
    }
    if (isScalarType(type)) {
        const resolved = mapToPrimitive(type.name) ||
            opts.customScalars[type.name] ||
            ((_a = type.extensions) === null || _a === void 0 ? void 0 : _a.jsonSchema) || {
            type: 'object',
        };
        return Object.assign({}, resolved);
    }
    if (isEnumType(type)) {
        return {
            type: 'string',
            enum: type.getValues().map((value) => value.name),
        };
    }
    return {
        type: 'object',
    };
}

function buildPathFromOperation({ url, schema, operation, useRequestBody, tags, description, customScalars, }) {
    const info = getOperationInfo(operation);
    const enumTypes = resolveEnumTypes(schema);
    const summary = resolveDescription(schema, info.operation);
    const variables = info.operation.variableDefinitions;
    const pathParams = variables === null || variables === void 0 ? void 0 : variables.filter((variable) => isInPath(url, variable.variable.name.value));
    const bodyParams = variables === null || variables === void 0 ? void 0 : variables.filter((variable) => !isInPath(url, variable.variable.name.value));
    return Object.assign(Object.assign({ tags,
        description,
        summary, operationId: info.name }, (useRequestBody
        ? {
            parameters: resolveParameters(url, pathParams, schema, info.operation, { customScalars, enumTypes }),
            requestBody: {
                content: {
                    'application/json': {
                        schema: resolveRequestBody(bodyParams, schema, info.operation, { customScalars, enumTypes }),
                    },
                },
            },
        }
        : {
            parameters: resolveParameters(url, variables, schema, info.operation, { customScalars, enumTypes }),
        })), { responses: {
            200: {
                description: summary,
                content: {
                    'application/json': {
                        schema: resolveResponse({
                            schema,
                            operation: info.operation,
                            opts: { customScalars, enumTypes },
                        }),
                    },
                },
            },
        } });
}
function resolveEnumTypes(schema) {
    const enumTypes = Object.values(schema.getTypeMap())
        .filter(isEnumType);
    return Object.fromEntries(enumTypes.map((type) => [
        type.name,
        {
            type: 'string',
            enum: type.getValues().map((value) => value.name),
        },
    ]));
}
function resolveParameters(url, variables, schema, operation, opts) {
    if (!variables) {
        return [];
    }
    return variables.map((variable) => {
        return {
            in: isInPath(url, variable.variable.name.value) ? 'path' : 'query',
            name: variable.variable.name.value,
            required: variable.type.kind === Kind.NON_NULL_TYPE,
            schema: resolveParamSchema(variable.type, opts),
            description: resolveVariableDescription(schema, operation, variable),
        };
    });
}
function resolveRequestBody(variables, schema, operation, opts) {
    if (!variables) {
        return {};
    }
    const properties = {};
    const required = [];
    variables.forEach((variable) => {
        if (variable.type.kind === Kind.NON_NULL_TYPE) {
            required.push(variable.variable.name.value);
        }
        properties[variable.variable.name.value] = Object.assign(Object.assign({}, resolveParamSchema(variable.type, opts)), { description: resolveVariableDescription(schema, operation, variable) });
    });
    return Object.assign({ type: 'object', properties }, (required.length ? { required } : {}));
}
// array -> [type]
// type -> $ref
// scalar -> swagger primitive
function resolveParamSchema(type, opts) {
    if (type.kind === Kind.NON_NULL_TYPE) {
        return resolveParamSchema(type.type, opts);
    }
    if (type.kind === Kind.LIST_TYPE) {
        return {
            type: 'array',
            items: resolveParamSchema(type.type, opts),
        };
    }
    const primitive = mapToPrimitive(type.name.value);
    return (primitive ||
        opts.customScalars[type.name.value] ||
        opts.enumTypes[type.name.value] || { $ref: mapToRef(type.name.value) });
}
function resolveResponse({ schema, operation, opts, }) {
    const operationType = operation.operation;
    const rootField = operation.selectionSet.selections[0];
    if (rootField.kind === Kind.FIELD) {
        if (operationType === 'query') {
            const queryType = schema.getQueryType();
            const field = queryType.getFields()[rootField.name.value];
            return resolveFieldType(field.type, opts);
        }
        if (operationType === 'mutation') {
            const mutationType = schema.getMutationType();
            const field = mutationType.getFields()[rootField.name.value];
            return resolveFieldType(field.type, opts);
        }
    }
}
function isInPath(url, param) {
    return url.includes(`:${param}`) || url.includes(`{${param}}`);
}
function getOperationFieldNode(schema, operation) {
    const selection = operation.selectionSet.selections[0];
    const fieldName = selection.name.value;
    const typeDefinition = schema.getType(titleCase(operation.operation));
    if (!typeDefinition) {
        return undefined;
    }
    const definitionNode = typeDefinition.astNode || parse(printType(typeDefinition)).definitions[0];
    if (!isObjectTypeDefinitionNode(definitionNode)) {
        return undefined;
    }
    return definitionNode.fields.find((field) => field.name.value === fieldName);
}
function resolveDescription(schema, operation) {
    var _a;
    const fieldNode = getOperationFieldNode(schema, operation);
    return ((_a = fieldNode === null || fieldNode === void 0 ? void 0 : fieldNode.description) === null || _a === void 0 ? void 0 : _a.value) || '';
}
function resolveVariableDescription(schema, operation, variable) {
    var _a, _b;
    const fieldNode = getOperationFieldNode(schema, operation);
    const argument = (_a = fieldNode === null || fieldNode === void 0 ? void 0 : fieldNode.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === variable.variable.name.value);
    return (_b = argument === null || argument === void 0 ? void 0 : argument.description) === null || _b === void 0 ? void 0 : _b.value;
}
function isObjectTypeDefinitionNode(node) {
    return node.kind === Kind.OBJECT_TYPE_DEFINITION;
}

const defaultErrorHandler = (errors) => {
    var _a;
    let status;
    const headers = {
        'Content-Type': 'application/json; charset=utf-8',
    };
    for (const error of errors) {
        if (typeof error === 'object' &&
            error != null &&
            ((_a = error.extensions) === null || _a === void 0 ? void 0 : _a.http)) {
            if (error.extensions.http.status &&
                (!status || error.extensions.http.status > status)) {
                status = error.extensions.http.status;
            }
            if (error.extensions.http.headers) {
                Object.assign(headers, error.extensions.http.headers);
            }
            delete error.extensions.http;
        }
    }
    if (!status) {
        status = 500;
    }
    return Response.json({ errors }, {
        status,
        headers,
    });
};
function useRequestBody(method) {
    return method === 'POST' || method === 'PUT' || method === 'PATCH';
}
function createRouter(sofa) {
    var _a, _b, _c, _d, _e, _f;
    logger.debug('[Sofa] Creating router');
    sofa.openAPI || (sofa.openAPI = {});
    (_a = sofa.openAPI).info || (_a.info = {});
    (_b = sofa.openAPI.info).title || (_b.title = 'SOFA API');
    (_c = sofa.openAPI.info).description || (_c.description = 'Generated by SOFA');
    (_d = sofa.openAPI.info).version || (_d.version = '0.0.0');
    (_e = sofa.openAPI).components || (_e.components = {});
    (_f = sofa.openAPI.components).schemas || (_f.schemas = {});
    const types = sofa.schema.getTypeMap();
    for (const typeName in types) {
        const type = types[typeName];
        if ((isObjectType(type) || isInputObjectType(type)) &&
            !isIntrospectionType(type)) {
            sofa.openAPI.components.schemas[typeName] = buildSchemaObjectFromType(type, {
                customScalars: sofa.customScalars,
            });
        }
    }
    const router = createRouter$1({
        base: sofa.basePath,
        openAPI: sofa.openAPI,
        swaggerUI: sofa.swaggerUI,
    });
    const queryType = sofa.schema.getQueryType();
    const mutationType = sofa.schema.getMutationType();
    const subscriptionManager = new SubscriptionManager(sofa);
    if (queryType) {
        Object.keys(queryType.getFields()).forEach((fieldName) => {
            createQueryRoute({ sofa, router, fieldName });
        });
    }
    if (mutationType) {
        Object.keys(mutationType.getFields()).forEach((fieldName) => {
            createMutationRoute({ sofa, router, fieldName });
        });
    }
    router.route({
        path: '/webhook',
        method: 'POST',
        handler(request, serverContext) {
            return __awaiter(this, void 0, void 0, function* () {
                const { subscription, variables, url } = yield request.json();
                try {
                    const sofaContext = Object.assign(serverContext, {
                        request,
                    });
                    const result = yield subscriptionManager.start({
                        subscription,
                        variables,
                        url,
                    }, sofaContext);
                    return Response.json(result);
                }
                catch (error) {
                    return Response.json(error, {
                        status: 500,
                        statusText: 'Subscription failed',
                    });
                }
            });
        }
    });
    router.route({
        path: '/webhook/:id',
        method: 'POST',
        handler(request, serverContext) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const id = (_a = request.params) === null || _a === void 0 ? void 0 : _a.id;
                const body = yield request.json();
                const variables = body.variables;
                try {
                    const sofaContext = Object.assign(serverContext, {
                        request,
                    });
                    const contextValue = yield sofa.contextFactory(sofaContext);
                    const result = yield subscriptionManager.update({
                        id,
                        variables,
                    }, contextValue);
                    return Response.json(result);
                }
                catch (error) {
                    return Response.json(error, {
                        status: 500,
                        statusText: 'Subscription failed to update',
                    });
                }
            });
        }
    });
    router.route({
        path: '/webhook/:id',
        method: 'DELETE',
        handler(request) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const id = (_a = request.params) === null || _a === void 0 ? void 0 : _a.id;
                try {
                    const result = yield subscriptionManager.stop(id);
                    return Response.json(result);
                }
                catch (error) {
                    return Response.json(error, {
                        status: 500,
                        statusText: 'Subscription failed to stop',
                    });
                }
            });
        }
    });
    return router;
}
function createQueryRoute({ sofa, router, fieldName, }) {
    var _a, _b, _c, _d, _e, _f, _g;
    logger.debug(`[Router] Creating ${fieldName} query`);
    const queryType = sofa.schema.getQueryType();
    const operationNode = buildOperationNodeForField({
        kind: 'query',
        schema: sofa.schema,
        field: fieldName,
        models: sofa.models,
        ignore: sofa.ignore,
        circularReferenceDepth: sofa.depthLimit,
    });
    const operation = {
        kind: Kind.DOCUMENT,
        definitions: [operationNode],
    };
    const info = getOperationInfo(operation);
    const field = queryType.getFields()[fieldName];
    const fieldType = field.type;
    const isSingle = isObjectType(fieldType) ||
        (isNonNullType(fieldType) && isObjectType(fieldType.ofType));
    const hasIdArgument = field.args.some((arg) => arg.name === 'id');
    const graphqlPath = `${queryType.name}.${fieldName}`;
    const routeConfig = (_a = sofa.routes) === null || _a === void 0 ? void 0 : _a[graphqlPath];
    const route = {
        method: (_b = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.method) !== null && _b !== void 0 ? _b : 'GET',
        path: (_c = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.path) !== null && _c !== void 0 ? _c : getPath(fieldName, isSingle && hasIdArgument),
        responseStatus: (_d = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.responseStatus) !== null && _d !== void 0 ? _d : 200,
    };
    router.route({
        path: route.path,
        method: route.method,
        schemas: getRouteSchemas({
            method: route.method,
            path: route.path,
            info,
            sofa,
            responseStatus: route.responseStatus,
        }),
        handler: useHandler({ info, route, fieldName, sofa, operation }),
    });
    logger.debug(`[Router] ${fieldName} query available at ${route.method} ${route.path}`);
    return {
        document: operation,
        path: route.path,
        method: route.method.toUpperCase(),
        tags: (_e = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.tags) !== null && _e !== void 0 ? _e : [],
        description: (_g = (_f = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.description) !== null && _f !== void 0 ? _f : field.description) !== null && _g !== void 0 ? _g : '',
    };
}
function getRouteSchemas({ method, path, info, sofa, responseStatus, }) {
    const params = {
        properties: {},
        required: [],
    };
    const query = {
        properties: {},
        required: [],
    };
    for (const variable of info.variables) {
        const varSchema = resolveParamSchema(variable.type, {
            customScalars: sofa.customScalars,
            enumTypes: sofa.enumTypes,
        });
        varSchema.description = resolveVariableDescription(sofa.schema, info.operation, variable);
        const varName = variable.variable.name.value;
        const varObj = isInPath(path, varName) ? params : query;
        varObj.properties[varName] = varSchema;
        if (variable.type.kind === Kind.NON_NULL_TYPE) {
            varObj.required.push(varName);
        }
    }
    return {
        request: {
            json: useRequestBody(method) ? resolveRequestBody(info.variables, sofa.schema, info.operation, {
                customScalars: sofa.customScalars,
                enumTypes: sofa.enumTypes,
            }) : undefined,
            params,
            query,
        },
        responses: {
            [responseStatus]: resolveResponse({
                schema: sofa.schema,
                operation: info.operation,
                opts: {
                    customScalars: sofa.customScalars,
                    enumTypes: sofa.enumTypes,
                }
            })
        }
    };
}
function createMutationRoute({ sofa, router, fieldName, }) {
    var _a, _b, _c, _d, _e, _f;
    logger.debug(`[Router] Creating ${fieldName} mutation`);
    const mutationType = sofa.schema.getMutationType();
    const field = mutationType.getFields()[fieldName];
    const operationNode = buildOperationNodeForField({
        kind: 'mutation',
        schema: sofa.schema,
        field: fieldName,
        models: sofa.models,
        ignore: sofa.ignore,
        circularReferenceDepth: sofa.depthLimit,
    });
    const operation = {
        kind: Kind.DOCUMENT,
        definitions: [operationNode],
    };
    const info = getOperationInfo(operation);
    const graphqlPath = `${mutationType.name}.${fieldName}`;
    const routeConfig = (_a = sofa.routes) === null || _a === void 0 ? void 0 : _a[graphqlPath];
    const method = (_b = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.method) !== null && _b !== void 0 ? _b : 'POST';
    const path = (_c = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.path) !== null && _c !== void 0 ? _c : getPath(fieldName);
    const responseStatus = (_d = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.responseStatus) !== null && _d !== void 0 ? _d : 200;
    const route = {
        method,
        path,
        responseStatus,
    };
    router.route({
        method,
        path,
        schemas: getRouteSchemas({
            method,
            path,
            info,
            responseStatus,
            sofa,
        }),
        handler: useHandler({ info, route, fieldName, sofa, operation }),
    });
    logger.debug(`[Router] ${fieldName} mutation available at ${method} ${path}`);
    return {
        document: operation,
        path,
        method,
        tags: (routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.tags) || [],
        description: (_f = (_e = routeConfig === null || routeConfig === void 0 ? void 0 : routeConfig.description) !== null && _e !== void 0 ? _e : field.description) !== null && _f !== void 0 ? _f : '',
    };
}
function useHandler(config) {
    const { sofa, operation, fieldName } = config;
    const info = config.info;
    const errorHandler = sofa.errorHandler || defaultErrorHandler;
    return (request, serverContext) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        try {
            let body = {};
            if (request.body != null) {
                const strBody = yield request.text();
                if (strBody) {
                    try {
                        body = JSON.parse(strBody);
                    }
                    catch (error) {
                        throw createGraphQLError('POST body sent invalid JSON.', {
                            extensions: {
                                http: {
                                    status: 400,
                                }
                            }
                        });
                    }
                }
            }
            let variableValues = {};
            try {
                variableValues = info.variables.reduce((variables, variable) => {
                    const name = variable.variable.name.value;
                    const value = parseVariable({
                        value: pickParam({
                            url: request.url,
                            body,
                            params: request.params || {},
                            name,
                        }),
                        variable,
                        schema: sofa.schema,
                    });
                    if (typeof value === 'undefined') {
                        return variables;
                    }
                    return Object.assign(Object.assign({}, variables), { [name]: value });
                }, {});
            }
            catch (error) {
                throw createGraphQLError(error.message || ((_a = error.toString) === null || _a === void 0 ? void 0 : _a.call(error)) || error, {
                    extensions: {
                        http: {
                            status: 400,
                        }
                    }
                });
            }
            const sofaContext = Object.assign(serverContext, {
                request,
            });
            const contextValue = yield sofa.contextFactory(sofaContext);
            const result = yield sofa.execute({
                schema: sofa.schema,
                document: operation,
                contextValue,
                variableValues,
                operationName: info.operation.name && info.operation.name.value,
            });
            if (result.errors) {
                return errorHandler(result.errors);
            }
            return Response.json((_b = result.data) === null || _b === void 0 ? void 0 : _b[fieldName], {
                status: config.route.responseStatus,
            });
        }
        catch (error) {
            return errorHandler([error]);
        }
    });
}
function getPath(fieldName, hasId = false) {
    return `/${convertName(fieldName)}${hasId ? '/:id' : ''}`;
}
function pickParam({ name, url, params, body, }) {
    if (name in params) {
        return params[name];
    }
    const searchParams = new URLSearchParams(url.split('?')[1]);
    if (searchParams.has(name)) {
        const values = searchParams.getAll(name);
        return values.length === 1 ? values[0] : values;
    }
    if (body && body.hasOwnProperty(name)) {
        return body[name];
    }
}

function createSofa(config) {
    logger.debug('[Sofa] Created');
    const models = extractsModels(config.schema);
    const ignore = config.ignore || [];
    const depthLimit = config.depthLimit || 1;
    logger.debug(`[Sofa] models: ${models.join(', ')}`);
    logger.debug(`[Sofa] ignore: ${ignore.join(', ')}`);
    return Object.assign({ execute,
        subscribe,
        models,
        ignore,
        depthLimit,
        contextFactory(serverContext) {
            if (config.context != null) {
                if (isContextFn(config.context)) {
                    return config.context(serverContext);
                }
                else {
                    return config.context;
                }
            }
            return serverContext;
        }, customScalars: config.customScalars || {}, enumTypes: config.enumTypes || {} }, config);
}
function isContextFn(context) {
    return typeof context === 'function';
}
// Objects and Unions are the only things that are used to define return types
// and both might contain an ID
// We don't treat Unions as models because
// they might represent an Object that is not a model
// We check it later, when an operation is being built
function extractsModels(schema) {
    var _a, _b;
    const modelMap = {};
    const query = schema.getQueryType();
    const fields = query.getFields();
    // if Query[type] (no args) and Query[type](just id as an argument)
    // loop through every field
    for (const fieldName in fields) {
        const field = fields[fieldName];
        const namedType = getNamedType(field.type);
        if (hasID(namedType)) {
            if (!modelMap[namedType.name]) {
                modelMap[namedType.name] = {};
            }
            if (isArrayOf(field.type, namedType)) {
                // check if type is a list
                // check if name of a field matches a name of a named type (in plural)
                // check if has no non-optional arguments
                // add to registry with `list: true`
                const sameName = isNameEqual(field.name, namedType.name + 's');
                const allOptionalArguments = !field.args.some((arg) => isNonNullType(arg.type));
                (_a = modelMap[namedType.name]).list || (_a.list = sameName && allOptionalArguments);
            }
            else if (isObjectType(field.type) ||
                (isNonNullType(field.type) && isObjectType(field.type.ofType))) {
                // check if type is a graphql object type
                // check if name of a field matches with name of an object type
                // check if has only one argument named `id`
                // add to registry with `single: true`
                const sameName = isNameEqual(field.name, namedType.name);
                const hasIdArgument = field.args.length === 1 && field.args[0].name === 'id';
                (_b = modelMap[namedType.name]).single || (_b.single = sameName && hasIdArgument);
            }
        }
    }
    return Object.keys(modelMap).filter((name) => modelMap[name].list && modelMap[name].single);
}
// it's dumb but let's leave it for now
function isArrayOf(type, expected) {
    const typeNameInSdl = type.toString();
    return (typeNameInSdl.includes('[') && typeNameInSdl.includes(expected.toString()));
}
function hasID(type) {
    return isObjectType(type) && !!type.getFields().id;
}
function isNameEqual(a, b) {
    return convertName(a) === convertName(b);
}

function OpenAPI({ schema, info, servers, components, security, tags, customScalars = {}, }) {
    const types = schema.getTypeMap();
    const swagger = {
        openapi: '3.0.0',
        info,
        servers,
        tags: [],
        paths: {},
        components: {
            schemas: {},
        },
    };
    for (const typeName in types) {
        const type = types[typeName];
        if ((isObjectType(type) || isInputObjectType(type)) &&
            !isIntrospectionType(type)) {
            swagger.components.schemas[typeName] = buildSchemaObjectFromType(type, {
                customScalars,
            });
        }
    }
    if (components) {
        swagger.components = Object.assign(Object.assign({}, components), swagger.components);
    }
    if (security) {
        swagger.security = security;
    }
    if (tags) {
        swagger.tags = tags;
    }
    return {
        addRoute(info, config) {
            const basePath = (config === null || config === void 0 ? void 0 : config.basePath) || '';
            const path = basePath +
                normalizePathParamForOpenAPI(info.path);
            if (!swagger.paths[path]) {
                swagger.paths[path] = {};
            }
            const pathsObj = swagger.paths[path];
            pathsObj[info.method.toLowerCase()] = buildPathFromOperation({
                url: path,
                operation: info.document,
                schema,
                useRequestBody: ['POST', 'PUT', 'PATCH'].includes(info.method),
                tags: info.tags || [],
                description: info.description || '',
                customScalars,
            });
        },
        get() {
            return swagger;
        },
    };
}

function useSofa(config) {
    return createRouter(createSofa(config));
}

export { OpenAPI, useSofa };
