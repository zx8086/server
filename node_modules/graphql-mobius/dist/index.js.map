{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": [
    "/* eslint-disable @typescript-eslint/ban-ts-comment */\n/**\n * # Mobius\n *\n * ! Don't try to understand this\n * ! Dark art ahead\n *\n * ? Total hours wasted by this: 0\n *\n * @author saltyAom\n */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\ntype Whitespace =\n    | '\\u{9}' // '\\t'\n    | '\\u{A}' // '\\n'\n    | '\\u{20}' // ' '\n\ntype TrimLeft<V extends string> = V extends `${Whitespace}${infer R}`\n    ? TrimLeft<R>\n    : V\n\ntype TrimRight<V extends string> = V extends `${infer R}${Whitespace}`\n    ? TrimRight<R>\n    : V\n\ntype Trim<V extends string> = TrimLeft<TrimRight<V>>\n\ntype Split<\n    S extends string,\n    Delimiter extends string\n> = S extends `${infer Head}${Delimiter}${infer Tail}`\n    ? [Head, ...Split<Tail, Delimiter>]\n    : S extends Delimiter\n    ? []\n    : [S]\n\ntype SplitUnion<S extends string> = S extends `${infer Head}|${infer Tail}`\n    ? [Trim<Head>, ...SplitUnion<Tail>]\n    : S extends '|'\n    ? []\n    : [Trim<S>]\n\ntype GetLastLine<S extends string> = S extends `${infer Head}\\n${infer Tail}`\n    ? GetLastLine<Tail>\n    : S extends '\\n'\n    ? []\n    : S\n\ntype FirstWord<T extends string> = T extends `${infer A}${Whitespace}${infer _}`\n    ? A\n    : T\n\ntype Prettify<T> = {\n    [K in keyof T]: T[K]\n} & {}\n\ntype ExtractType<T extends string> = T extends `${infer Type}\\n${infer Rest}`\n    ? [TrimLeft<Type>, Rest]\n    : T extends `${infer Type} ${infer Rest}`\n    ? [TrimLeft<Type>, Rest]\n    : never\n\n// enum and types\ntype CustomTypes = Record<string, string | Record<string, unknown>>\ntype Scalar = Record<string, unknown>\n\n/**\n * Actually a string\n */\ntype ID = string\n\ntype GQLTypes = {\n    String: string\n    Int: number\n    Float: number\n    Boolean: boolean\n    ID: ID\n}\n\ntype MergeInterface<\n    Interfaces extends string,\n    Known extends CustomTypes = {},\n    Types extends Record<string, unknown> = {}\n> = Interfaces extends `${infer Name}${',' | '&'}${infer Rest}`\n    ? MergeInterface<\n          Rest,\n          Known,\n          Types &\n              (Trim<Name> extends infer Key extends keyof Known\n                  ? Known[Key]\n                  : never)\n      >\n    : Types &\n          (Trim<Interfaces> extends infer Key extends keyof Known\n              ? Known[Key]\n              : never)\n\nexport type RemoveComment<T extends string> = RemoveMultiLineComment<\n    RemoveSingleLineComment<T>\n>\n\ntype RemoveSingleLineComment<T extends string> =\n    T extends `${infer First}#${infer Comment}\\n${infer Rest}`\n        ? `${First}${RemoveSingleLineComment<Rest>}`\n        : T\n\ntype RemoveMultiLineComment<T extends string> =\n    T extends `${infer First}\"\"\"${infer Comment}\"\"\"${infer Rest}`\n        ? `${First}${RemoveMultiLineComment<Rest>}`\n        : T\n\nexport type CreateInnerMobius<\n    T extends string,\n    Known extends CustomTypes = {}\n> = T extends `${infer Ops}{${infer Schema}}${infer Rest}`\n    ? Trim<RemoveComment<Ops>> extends `${infer Keyword} ${infer Name}`\n        ? CreateInnerMobius<\n              Rest,\n              Known &\n                  (Keyword extends 'type'\n                      ? {\n                            [name in TrimLeft<FirstWord<Name>>]: Prettify<\n                                MapSchema<RemoveComment<Schema>, Known> &\n                                    (Name extends `${infer _} implements ${infer Interfaces}`\n                                        ? MergeInterface<Interfaces, Known>\n                                        : {})\n                            >\n                        }\n                      : Keyword extends 'input' | 'interface'\n                      ? {\n                            [name in TrimLeft<Name>]: Prettify<\n                                MapSchema<RemoveComment<Schema>>\n                            >\n                        }\n                      : Keyword extends 'enum'\n                      ? {\n                            [name in TrimLeft<Name>]: Exclude<\n                                NonNullable<MapEnum<RemoveComment<Schema>>>,\n                                ''\n                            >\n                        }\n                      : Keyword extends 'fragment'\n                      ? {\n                            Fragment: {\n                                [name in TrimLeft<FirstWord<Name>>]: Prettify<\n                                    Name extends `${infer _} on ${infer Target}`\n                                        ? {\n                                              Target: Target\n                                              Value: Exclude<\n                                                  MapEnum<\n                                                      RemoveComment<Schema>\n                                                  >,\n                                                  '' | null | undefined\n                                              >\n                                          }\n                                        : {}\n                                >\n                            }\n                        }\n                      : Keyword extends 'directive'\n                      ? CreateInnerMobius<\n                            // ? TypeScript is greedy\n                            `${TrimLeft<\n                                GetLastLine<Ops>\n                            >}{${RemoveComment<Schema>}}`,\n                            Known\n                        >\n                      : Keyword extends 'union'\n                      ? CreateInnerMobius<\n                            // ? TypeScript is greedy\n                            `${TrimLeft<\n                                GetLastLine<Ops>\n                            >}{${RemoveComment<Schema>}}`,\n                            Known & MapUnion<Ops, Known>\n                        >\n                      : /**\n                       * ? TypeScript is greedy, scalar can eat other word until\n                       * ? next bracket match which means types left over is possible\n                       **/\n                      Keyword extends 'scalar'\n                      ? TrimLeft<\n                            RemoveComment<Ops>\n                        > extends `${infer _}\\n${infer Prefix}`\n                          ? CreateInnerMobius<`${Prefix}{${Schema}}`, Known>\n                          : {}\n                      : {})\n          >\n        : Known\n    : Known\n\ntype MapInnerUnion<\n    T extends string[],\n    Known extends CustomTypes,\n    Carry extends Record<string, unknown> = {}\n> = T extends [infer First extends string, ...infer Rest extends string[]]\n    ? MapInnerUnion<\n          Rest,\n          Known,\n          Prettify<\n              Known extends { [a in First]: infer A }\n                  ? A extends string | boolean | number | symbol\n                      ? Carry | A\n                      : Carry & A\n                  : Carry\n          >\n      >\n    : Carry\n\ntype MapUnion<\n    T extends string,\n    Known extends CustomTypes = {}\n> = T extends `${infer _}union ${infer Name}=${infer Mapped}\\n${infer Rest}`\n    ? {\n          [name in TrimRight<Name>]: MapInnerUnion<SplitUnion<Mapped>, Known>\n      } & MapUnion<`\\n${Rest}`, Known>\n    : {}\n\ntype MapEnum<\n    T extends string,\n    Carry extends string | null = null\n> = T extends `${infer Name}${Whitespace | ','}${infer Rest}`\n    ? MapEnum<Rest, Trim<Name> | Carry>\n    : T extends `${infer Name}`\n    ? Carry | Trim<Name>\n    : Carry\n\ntype MapSchema<\n    T extends string,\n    Known extends CustomTypes = {}\n> = T extends `${infer Name}:${infer Type}`\n    ? Name extends `${infer Name}(${infer Params}`\n        ? T extends `${infer Name}(${infer Params}):${infer Type}`\n            ? ExtractType<Type> extends [\n                  infer Type extends string,\n                  infer Rest extends string\n              ]\n                ? {\n                      [word in Name as TrimLeft<Name> extends infer Candidate extends string\n                          ? Candidate extends `#${infer _}`\n                              ? never\n                              : Candidate\n                          : never]: Prettify<\n                          MapArgument<Params, Known>\n                      > extends infer Argument\n                          ? Partial<Argument> extends Argument\n                              ? (p?: Argument) => FormatType<Type>\n                              : (p: Argument) => FormatType<Type>\n                          : never\n                  } & MapSchema<Rest, Known>\n                : {}\n            : {}\n        : ExtractType<Type> extends [\n              infer Type extends string,\n              infer Rest extends string\n          ]\n        ? {\n              [word in Name as TrimLeft<Name>]: FormatType<Type>\n          } & MapSchema<Rest, Known>\n        : {}\n    : {}\n\ntype RemovePrefixArrayBracket<T extends string> = T extends `[${infer Rest}`\n    ? RemovePrefixArrayBracket<Rest>\n    : T\n\n// @ts-ignore To hard to explain this shape in TS, I works trust me\ntype CreateArray<\n    T extends string,\n    // @ts-ignore\n    Carry extends string | null = (\n        RemovePrefixArrayBracket<T> extends `${infer Name}]${string}` ? Name : T\n    ) extends infer Name\n        ? Name extends `${infer A}!${string}`\n            ? A\n            : Name | null\n        : never\n    // @ts-ignore\n> = T extends `[${infer Rest}` ? CreateArray<Rest, [Carry]> : Carry\n\ntype FormatType<T extends string> = FirstWord<T> extends infer T\n    ? T extends `[${string}`\n        ? // ? Is Array\n          T extends `${infer Type}!`\n            ? CreateArray<Type>\n            : CreateArray<T> | null\n        : // ? Not Array\n        T extends `${infer Type}!`\n        ? Type\n        : T | null\n    : never\n\ntype MapArgument<\n    T extends string,\n    Known extends CustomTypes = {},\n    Carry extends Record<string, unknown> = {}\n> = T extends `${infer Name}:${infer Type}${'\\n' | ','}${infer Rest}`\n    ? MapArgument<\n          Rest,\n          Known,\n          Type extends `${infer _}!${infer Rest}`\n              ? Rest extends `${string}=${string}`\n                  ? Carry & {\n                        [name in TrimLeft<Name>]?: FormatType<\n                            FirstWord<TrimLeft<Type>>\n                        >\n                    }\n                  : Carry & {\n                        [name in TrimLeft<Name>]: FormatType<\n                            FirstWord<TrimLeft<Type>>\n                        >\n                    }\n              : Carry & {\n                    [name in TrimLeft<Name>]?: FormatType<\n                        FirstWord<TrimLeft<Type>>\n                    >\n                }\n      >\n    : T extends `${infer Name}:${infer Type}`\n    ? Type extends `${infer _}!${infer Rest}`\n        ? Rest extends `${string}=${string}`\n            ? Carry & {\n                  [name in TrimLeft<Name>]?: FormatType<\n                      FirstWord<TrimLeft<Type>>\n                  >\n              }\n            : Carry & {\n                  [name in TrimLeft<Name>]: FormatType<\n                      FirstWord<TrimLeft<Type>>\n                  >\n              }\n        : Carry & {\n              [name in TrimLeft<Name>]?: FormatType<FirstWord<TrimLeft<Type>>>\n          }\n    : Carry\n\ntype MapFragment<\n    Typed extends Record<string, unknown> & {\n        Fragment: Record<\n            string,\n            {\n                Target: string\n                Value: string\n            }\n        >\n    }\n> = Typed extends { Fragment: infer Fragments }\n    ? Omit<Typed, 'Fragment'> & {\n          Fragment: Prettify<{\n              [K in keyof Fragments]: Fragments[K] extends {\n                  Target: infer Target extends string\n                  Value: infer Value\n              }\n                  ? Typed extends {\n                        [a in Target]: infer Schema extends {\n                            [a in Extract<Value, string>]: unknown\n                        }\n                    }\n                      ? Prettify<Pick<Schema, Extract<Value, string>>>\n                      : {}\n                  : {\n                        K: K\n                        F: Fragments\n                    }\n          }>\n      }\n    : Typed\n\n/**\n * Infers GraphQL types to TypeScript\n *\n * @example\n * ```ts\n * ```ts\n * import type { CreateMobius } from 'graphql-mobius'\n *\n * const typeDefs = `\n *     # Hello World\n *     type A {\n *         A: String!\n *         B: String!\n *     }\n *\n *     # Hello World\n *     type Query {\n *         Hello(word: String!): A!\n *     }\n * `\n *\n * // This is an equivalent to calling new Mobius().mobius\n * type Engine = CreateMobius<typeof typeDefs>\n * ```\n */\nexport type CreateMobius<\n    T extends string,\n    Scalars extends Scalar = {}\n> = CreateInnerMobius<T> extends infer Typed\n    ? Prettify<\n          // @ts-ignore\n          MapFragment<ResolveType<Typed, Scalars>> &\n              ('Query' extends keyof Typed\n                  ? {}\n                  : {\n                        Query: {}\n                    }) &\n              ('Mutation' extends keyof Typed\n                  ? {}\n                  : {\n                        Mutation: {}\n                    }) &\n              ('Subscription' extends keyof Typed\n                  ? {}\n                  : {\n                        Subscription: {}\n                    }) &\n              ('Fragment' extends keyof Typed\n                  ? {}\n                  : {\n                        Fragment: {}\n                    }) &\n              Scalars\n      >\n    : never\n\n// ? Quick way to display an error (interface so it displays it correctly)\ninterface Err<T> {\n    [key: PropertyKey]: never\n}\n\ntype MData = string | Function | null | [MData]\n\ntype UnwrapKey<\n    K extends MData,\n    Result extends Record<string, unknown>,\n    Scalars extends Record<string, unknown>,\n    Nullable = null extends K ? null : never\n> = NonNullable<K> extends (infer Next extends MData)[]\n    ? UnwrapKey<Next, Result, Scalars>[] | Nullable\n    : ResolveKey<K & string, Result, Scalars> | Nullable\n\ntype ResolveKey<\n    K extends string,\n    Result extends Record<string, unknown>,\n    Scalars extends Record<string, unknown>\n> = K extends (p: infer Params) => infer Returned\n    ? {\n          [K in keyof Params]: UnwrapKey<\n              // @ts-ignore: Trust me bro\n              NonNullable<Params[K]>,\n              Result,\n              Scalars\n          >\n      } extends infer Argument\n        ? Partial<Argument> extends Argument\n            ? // @ts-ignore: Trust me bro\n              (p?: Argument) => UnwrapKey<Returned, Result, Scalars>\n            : // @ts-ignore: Trust me bro\n              (p: Argument) => UnwrapKey<Returned, Result, Scalars>\n        : never\n    : K extends keyof Scalars\n    ? Scalars[K]\n    : K extends keyof Result\n    ? Result[K]\n    : unknown // Err<[\"Couldn't resolve the key \", K]>\n\ninterface ResolveInnerType<\n    Data extends Record<string, unknown | Record<string, MData>>,\n    Scalars extends Record<string, unknown> = {}\n> {\n    result: {\n        [KI in keyof Data]: Data[KI] extends Record<string, MData>\n            ? {\n                  [KJ in keyof Data[KI]]: UnwrapKey<\n                      Data[KI][KJ],\n                      this['result'],\n                      Scalars & GQLTypes\n                  >\n              }\n            : Data[KI]\n    }\n}\n\nexport type ResolveType<\n    Data extends Record<string, unknown | Record<string, MData>>,\n    Scalars extends Record<string, unknown> = {}\n> = ResolveInnerType<Data, Scalars>['result']\n\ntype AddUndefinedIfNullable<T> = T extends null | undefined ? T | undefined : T\n\ntype UndefinedToNullableFields<T> = T extends object\n    ? {\n          [K in keyof T]?: UndefinedToNullableFields<\n              AddUndefinedIfNullable<T[K]>\n          >\n      }\n    : AddUndefinedIfNullable<T>\n\ntype MaybePromise<T> = T | Promise<T>\n\nexport type Resolver<\n    T extends {\n        Query: Record<string, unknown>\n        Mutation: Record<string, unknown>\n        Subscription: Record<string, unknown>\n    },\n    Context = unknown\n> = Prettify<\n    ({\n        [K in keyof T['Query']]: T['Query'][K] extends (\n            arg: infer Args\n        ) => infer Returned\n            ? (\n                  parent: unknown,\n                  args: Args,\n                  context: Context,\n                  info: unknown\n              ) =>\n                  | MaybePromise<UndefinedToNullableFields<Returned>>\n                  | (Returned extends null ? void : never)\n            : (\n                  parent: unknown,\n                  args: null | undefined | {},\n                  context: Context,\n                  info: unknown\n              ) =>\n                  | MaybePromise<UndefinedToNullableFields<T['Query'][K]>>\n                  | (T['Query'][K] extends null ? void : never)\n    } extends infer A\n        ? {} extends A\n            ? { Query?: {} }\n            : { Query: A }\n        : never) &\n        ({\n            [K in keyof T['Mutation']]: T['Mutation'][K] extends (\n                arg: infer Args\n            ) => infer Returned\n                ? (\n                      parent: unknown,\n                      args: Args,\n                      context: Context,\n                      info: unknown\n                  ) =>\n                      | MaybePromise<UndefinedToNullableFields<Returned>>\n                      | (Returned extends null ? void : never)\n                : (\n                      parent: unknown,\n                      args: null | undefined | {},\n                      context: Context,\n                      info: unknown\n                  ) =>\n                      | MaybePromise<\n                            UndefinedToNullableFields<T['Mutation'][K]>\n                        >\n                      | (T['Mutation'][K] extends null ? void : never)\n        } extends infer A\n            ? {} extends A\n                ? { Mutation?: {} }\n                : { Mutation: A }\n            : never) &\n        ({\n            [K in keyof T['Subscription']]: T['Subscription'][K] extends (\n                arg: infer Args\n            ) => infer Returned\n                ? (\n                      parent: unknown,\n                      args: Args,\n                      context: Context,\n                      info: unknown\n                  ) =>\n                      | MaybePromise<UndefinedToNullableFields<Returned>>\n                      | (Returned extends null ? void : never)\n                : (\n                      parent: unknown,\n                      args: null | undefined | {},\n                      context: Context,\n                      info: unknown\n                  ) =>\n                      | MaybePromise<\n                            UndefinedToNullableFields<T['Subscription'][K]>\n                        >\n                      | (T['Subscription'][K] extends null ? void : never)\n        } extends infer A\n            ? {} extends A\n                ? { Subscription?: {} }\n                : { Subscription: A }\n            : never) &\n        Partial<Omit<T, 'Query' | 'Mutation' | 'Subscription' | 'Fragment'>>\n>\n\ntype Selective<T> = T extends object\n    ? {\n          [K in keyof T]?: K extends 'where' ? T[K] : Selective<T[K]>\n      } & ('where' extends keyof T\n          ? T['where'] extends NonNullable<T['where']>\n              ? {\n                    // @ts-ignore: always with where\n                    select: T['Select']\n                    where: T['where']\n                }\n              : {}\n          : {})\n    : T\n\ntype MaybeArray<T> = T | T[]\ntype UnwrapArray<T> = T extends Array<infer R>\n    ? R extends any[]\n        ? UnwrapArray<R>\n        : R\n    : T\n\n/**\n * Create Prisma-like argument syntax for Client\n */\nexport type CreateQuery<T extends Record<string, unknown>> =\n    (NonNullable<T> extends infer T\n        ? {\n              [K in keyof T]: T[K] extends (_: infer Params) => infer Query\n                  ? NonNullable<UnwrapArray<NonNullable<Query>>> extends Record<\n                        string,\n                        unknown\n                    >\n                      ? NonNullable<\n                            UnwrapArray<Query>\n                        > extends infer A extends Record<string, unknown>\n                          ? {\n                                select: CreateQuery<A>\n                                where: Params\n                            }\n                          : {}\n                      : {\n                            select: true | undefined | null\n                            where: T[K] extends (_: infer Params) => any\n                                ? Params\n                                : never\n                        }\n                  : NonNullable<\n                        UnwrapArray<T[K]>\n                    > extends infer Query extends Record<string, unknown>\n                  ? {} extends UnwrapArray<Query>\n                      ? true | undefined | null\n                      : CreateQuery<UnwrapArray<Query>>\n                  : true | undefined | null\n          }\n        : never) & {\n        __typename?: true | undefined | null\n    }\n\ntype UnwrapFunctionalSchema<\n    Schema extends Record<string, unknown> | Function | null\n> = Schema extends (...p: any[]) => infer Returned\n    ? NonNullable<UnwrapArray<Returned>> extends infer A extends Record<\n          string,\n          unknown\n      >\n        ? A\n        : Returned\n    : Schema extends Record<string, unknown>\n    ? Schema\n    : never\n\ntype ResolveQuery<\n    Query extends Record<string, unknown>,\n    Model extends Record<string, unknown>\n> = {\n    [K in keyof Query]: Model extends Record<\n        K,\n        infer Schema extends Record<string, unknown> | Function | null\n    >\n        ? Model[K] extends (...args: any[]) => any[]\n            ? Resolve<Query, Model>[K][]\n            : Resolve<Query, Model>[K]\n        : never\n}\n\ntype Resolve<\n    Query extends Record<string, unknown>,\n    M extends Record<string, unknown>\n> = NonNullable<M> extends infer Model\n    ? Prettify<{\n          [K in keyof Query]: Model extends Record<\n              K,\n              infer Schema extends Record<string, unknown> | Function | null\n          >\n              ? Query[K] extends true\n                  ? Model[K]\n                  : Query[K] extends {\n                        select: infer Selected extends Record<string, unknown>\n                    }\n                  ? Resolve<Selected, UnwrapFunctionalSchema<Schema>>\n                  : Query[K] extends Record<string, unknown>\n                  ? Resolve<Query[K], UnwrapFunctionalSchema<Schema>>\n                  : {}\n              : K extends keyof Model\n              ? Model[K] extends Array<any>\n                  ? K extends keyof Query\n                      ? Resolve<\n                            Query[K] extends Record<string, unknown>\n                                ? Query[K]\n                                : {},\n                            Model[K][number]\n                        >[]\n                      : unknown[]\n                  : Model[K]\n              : never\n      }>\n    : never\n\n/**\n * Create Prisma-like function for GraphQL\n */\nexport type MakeExecutable<\n    TypeDefs extends {\n        Query: Record<string, unknown>\n        Mutation: Record<string, unknown>\n        Subscription: Record<string, unknown>\n    },\n    Scalars extends Scalar = {}\n> = <\n    Query extends Selective<CreateQuery<TypeDefs['Query']>>,\n    Mutate extends Selective<CreateQuery<TypeDefs['Mutation']>>,\n    Subscription extends Selective<CreateQuery<TypeDefs['Subscription']>>\n>(params: {\n    query?: Query\n    mutate?: Mutate\n    subscription?: Subscription\n}) => Promise<\n    Prettify<\n        ({} extends Query ? {} : Resolve<Query, TypeDefs['Query'] & Scalars>) &\n            ({} extends Mutate\n                ? {}\n                : Resolve<Mutate, TypeDefs['Mutation'] & Scalars>) &\n            ({} extends Subscription\n                ? {}\n                : Resolve<Subscription, TypeDefs['Subscription'] & Scalars>)\n    >\n>\n\n/**\n * Map Prisma-like JSON to GraphQL query (string)\n */\nexport const mobiusToGraphQL = <\n    T extends 'query' | 'mutation' | 'subscription'\n>(\n    type: T,\n    params: Record<T, Record<string, unknown>>\n) => {\n    const query = JSON.stringify(\n        params[type] ?? params,\n        (key, value) => {\n            if (typeof value !== 'object') return value\n\n            if (\n                typeof value === 'object' &&\n                'select' in value &&\n                !('where' in value)\n            )\n                return value.select\n\n            const mapped: Record<string, unknown> = {}\n\n            for (const [key, child] of Object.entries(value)) {\n                if (typeof child === 'object' && 'where' in child!) {\n                    mapped[`${key}(${JSON.stringify(child.where)})`] =\n                        // @ts-ignore select is always with where\n                        child.select\n                    continue\n                }\n\n                mapped[key] = child\n            }\n\n            return mapped\n        },\n        2\n    )\n\n    return (\n        type +\n        ' _ ' +\n        query\n            .replace(/\\\\/g, '')\n            // Query quote field to GraphQL\n            .replace(/(.*): {/g, (a) => a.slice(1, -3) + ' {')\n            // Quote field: true to GraphQL\n            .replace(/\"(\\w+)\": true(,)?/g, (a) =>\n                a.slice(1, a[a.length - 1] === ',' ? -8 : -7)\n            )\n            .replace(/\"(\\w+)(\\((.*)\\))?\" {/g, (a) => a.slice(1, -3) + ' {')\n            .replace(/\\(\\{/g, '(')\n            .replace(/\\}\\)/g, ')')\n            // Replace primitive value query\n            .replace(/\\): true/g, ')')\n            .replace(/\"(\\w+)\":/g, (a) => a.slice(1, -2) + ':')\n            // Remove query without object\n            .replace(/\"(\\w+)(\\((.*)\\))?\": true/g, (a) => a.slice(1, -7))\n    )\n}\n\n/**\n * /: Denotes the start and end of the regex pattern.\n * fragment: Matches the word \"fragment\" literally.\n * \\s+: Matches one or more whitespace characters (spaces, tabs, etc.).\n * (\\w+): Capturing group to match the fragment name. \\w+ matches one or more word characters (letters, digits, and underscores).\n * \\s+: Matches one or more whitespace characters.\n * on: Matches the word \"on\" literally.\n * \\s+: Matches one or more whitespace characters.\n * [\\w:]+: Matches one or more word characters and colons. This is used to match the type condition after \"on\" in the fragment.\n * \\s*: Matches zero or more whitespace characters.\n * {: Matches the opening curly brace.\n * ([^}]*): Capturing group to match the content of the fragment. [^}]* matches zero or more characters that are not closing curly braces.\n * }: Matches the closing curly brace.\n * /g: Global flag to match all occurrences of the pattern in the input string.\n */\nconst extractFragment = /fragment\\s+(\\w+)\\s+on\\s+[\\w:]+\\s*{([^}]*)}/g\n\n/**\n * Create fragments for usage in Prisma-like client\n */\nexport const createFragment = (schema: string) => {\n    const matches = schema.match(extractFragment)\n    if (!matches) return {}\n\n    const fragments: Record<string, Record<string, true>> = {}\n\n    if (matches) {\n        for (const match of matches) {\n            // @ts-ignore\n            const [, name, content] = extractFragment.exec(matches)!\n            const current: Record<string, true> = {}\n\n            for (const item of content.split(/(,|\\n)/g))\n                current[item.trim()] = true\n\n            fragments[name] = current\n        }\n    }\n\n    return fragments\n}\n\ntype ToSelectiveFragment<T extends Record<string, unknown>> = Prettify<{\n    [K in keyof T]: T[K] extends Record<string, unknown>\n        ? ToSelectiveFragment<T[K]>\n        : true\n}>\n\nexport class Mobius<\n    Declaration extends string = '',\n    const Scalars extends Scalar = {},\n    TypeDefs extends CreateMobius<Declaration, Scalars> = CreateMobius<\n        Declaration,\n        Scalars\n    >\n> {\n    /**\n     * ! For type declaration only\n     */\n    klein: TypeDefs | null = null\n\n    /**\n     * ! For type declaration only\n     */\n    resolvers: Resolver<TypeDefs> | null = null\n\n    /**\n     * Available if `typeDefs` is passed\n     */\n    fragments: ToSelectiveFragment<TypeDefs['Fragment']> | null = null\n\n    constructor(\n        public config?: {\n            url?: string\n            fetch?: (query: string) => Promise<unknown>\n            typeDefs?: Declaration\n        }\n    ) {\n        if (config?.typeDefs)\n            this.fragments = createFragment(config.typeDefs) as any\n    }\n\n    protected get fetch() {\n        return (\n            this.config?.fetch ??\n            ((query: string) =>\n                fetch(this.config?.url ?? '', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        query,\n                        variables: {}\n                    })\n                }).then((x) =>\n                    x.json().then((x) => (x as { data: unknown }).data)\n                ))\n        )\n    }\n\n    $<\n        Query extends Selective<CreateQuery<TypeDefs['Query']>>,\n        Mutate extends Selective<CreateQuery<TypeDefs['Mutation']>>,\n        Subscription extends Selective<CreateQuery<TypeDefs['Subscription']>>\n    >(params: {\n        query?: Query\n        mutate?: Mutate\n        subscription?: Subscription\n    }): {\n        query: string\n        mutation: string\n        subscription: string\n    } {\n        return {\n            query: mobiusToGraphQL('query', params as any),\n            mutation: mobiusToGraphQL('mutation', params as any),\n            subscription: mobiusToGraphQL('subscription', params as any)\n        }\n    }\n\n    query<Query extends Selective<CreateQuery<TypeDefs['Query']>>>(\n        params: Query\n    ): Promise<Prettify<\n        {} extends Query ? {} : ResolveQuery<Query, TypeDefs['Query'] & Scalars>\n    > | null> {\n        // @ts-ignore\n        return this.fetch(mobiusToGraphQL('query', params))\n    }\n\n    mutate<Mutate extends Selective<CreateQuery<TypeDefs['Mutation']>>>(\n        params: Mutate\n    ): Promise<\n        Prettify<\n            {} extends Mutate\n                ? {}\n                : ResolveQuery<Mutate, TypeDefs['Mutation'] & Scalars>\n        >\n    > {\n        // @ts-ignore\n        return this.fetch(mobiusToGraphQL('mutation', params))\n    }\n\n    subscription<\n        Subscription extends Selective<CreateQuery<TypeDefs['Subscription']>>\n    >(\n        params: Subscription\n    ): Promise<\n        Prettify<\n            {} extends Subscription\n                ? {}\n                : ResolveQuery<Subscription, TypeDefs['Subscription'] & Scalars>\n        >\n    > {\n        // @ts-ignore\n        return this.fetch(mobiusToGraphQL('subscription', params))\n    }\n}\n\nexport default Mobius\n"
  ],
  "mappings": "AAouBO,IAAM,EAAkB,CAG3B,EACA,IACC,CACD,MAAM,EAAQ,KAAK,UACf,EAAO,IAAS,EAChB,CAAC,EAAK,IAAU,CACZ,UAAW,IAAU,SAAU,OAAO,EAEtC,UACW,IAAU,WACjB,WAAY,MACV,UAAW,GAEb,OAAO,EAAM,OAEjB,MAAM,EAAkC,CAAC,EAEzC,QAAY,EAAK,KAAU,OAAO,QAAQ,CAAK,EAAG,CAC9C,UAAW,IAAU,WAAY,UAAW,GAAQ,CAChD,EAAO,GAAG,KAAO,KAAK,UAAU,EAAM,KAAK,MAEvC,EAAM,OACV,SAGJ,EAAO,GAAO,EAGlB,OAAO,GAEX,CACJ,EAEA,OACI,EACA,MACA,EACK,QAAQ,MAAO,EAAE,EAEjB,QAAQ,WAAY,CAAC,IAAM,EAAE,MAAM,GAAG,CAAE,EAAI,IAAI,EAEhD,QAAQ,qBAAsB,CAAC,IAC5B,EAAE,MAAM,EAAG,EAAE,EAAE,OAAS,KAAO,KAAM,GAAK,CAAE,CAChD,EACC,QAAQ,wBAAyB,CAAC,IAAM,EAAE,MAAM,GAAG,CAAE,EAAI,IAAI,EAC7D,QAAQ,QAAS,GAAG,EACpB,QAAQ,QAAS,GAAG,EAEpB,QAAQ,YAAa,GAAG,EACxB,QAAQ,YAAa,CAAC,IAAM,EAAE,MAAM,GAAG,CAAE,EAAI,GAAG,EAEhD,QAAQ,4BAA6B,CAAC,IAAM,EAAE,MAAM,GAAG,CAAE,CAAC,GAmBjE,EAAkB,8CAKX,EAAiB,CAAC,IAAmB,CAC9C,MAAM,EAAU,EAAO,MAAM,CAAe,EAC5C,IAAK,EAAS,MAAO,CAAC,EAEtB,MAAM,EAAkD,CAAC,EAEzD,GAAI,EACA,QAAW,KAAS,EAAS,CAEzB,OAAS,EAAM,GAAW,EAAgB,KAAK,CAAO,EAChD,EAAgC,CAAC,EAEvC,QAAW,KAAQ,EAAQ,MAAM,SAAS,EACtC,EAAQ,EAAK,KAAK,GAAK,GAE3B,EAAU,GAAQ,EAI1B,OAAO,GASJ,MAAM,CAOX,CAiBa,EAbX,MAAyB,KAKzB,UAAuC,KAKvC,UAA8D,KAE9D,WAAW,CACA,EAKT,CALS,cAMP,GAAI,GAAQ,SACR,KAAK,UAAY,EAAe,EAAO,QAAQ,KAGzC,MAAK,EAAG,CAClB,OACI,KAAK,QAAQ,QACZ,CAAC,IACE,MAAM,KAAK,QAAQ,KAAO,GAAI,CAC1B,OAAQ,OACR,QAAS,CACL,eAAgB,kBACpB,EACA,KAAM,KAAK,UAAU,CACjB,QACA,UAAW,CAAC,CAChB,CAAC,CACL,CAAC,EAAE,KAAK,CAAC,IACL,EAAE,KAAK,EAAE,KAAK,CAAC,IAAO,EAAwB,IAAI,CACtD,GAIZ,CAIC,CAAC,EAQA,CACE,MAAO,CACH,MAAO,EAAgB,QAAS,CAAa,EAC7C,SAAU,EAAgB,WAAY,CAAa,EACnD,aAAc,EAAgB,eAAgB,CAAa,CAC/D,EAGJ,KAA8D,CAC1D,EAGM,CAEN,OAAO,KAAK,MAAM,EAAgB,QAAS,CAAM,CAAC,EAGtD,MAAmE,CAC/D,EAOF,CAEE,OAAO,KAAK,MAAM,EAAgB,WAAY,CAAM,CAAC,EAGzD,YAEC,CACG,EAOF,CAEE,OAAO,KAAK,MAAM,EAAgB,eAAgB,CAAM,CAAC,EAEjE,CAEA,IAAe",
  "debugId": "0E51291E5EF54EAC64756e2164756e21",
  "names": []
}